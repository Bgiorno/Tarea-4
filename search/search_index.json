{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"M\u00e9todos de aproximacion En la resoluci\u00f3n de ecuaciones diferenciales ordinarias (ODEs), los m\u00e9todos num\u00e9ricos son esenciales para obtener aproximaciones cuando no se dispone de soluciones anal\u00edticas. A continuaci\u00f3n, se presenta una introducci\u00f3n a tres m\u00e9todos num\u00e9ricos comunes: el m\u00e9todo de Euler, el m\u00e9todo de Runge-Kutta de orden 2 (RK2) y el m\u00e9todo de Runge-Kutta de orden 4 (RK4). M\u00e9todo de Euler El m\u00e9todo de Euler es uno de los m\u00e9todos num\u00e9ricos m\u00e1s simples para resolver ODEs. Es un m\u00e9todo de primer orden, con error proporcional al cuadrado del tama\u00f1o del paso. La f\u00f3rmula b\u00e1sica para el m\u00e9todo de Euler es: $$ x_i = x_{i-1} + hf(x_i) $$ Donde: x_i - Es el valor de la funcion a aproximar evaluada en un tiempo t. h - Es el tama\u00f1o del paso f(x_i) - Es la funcion a la cual se le aplica el metodo. M\u00e9todo de Runge-Kutta de orden 2 El m\u00e9todo RK2 utiliza un punto medio para evaluar el m\u00e9todo de Euler, logrando una mejor aproximacion con un error del orden del cubo del tama\u00f1o del paso este m\u00e9todo se compone ahora de terminos k que se utlizan de manera recursiva, tal que el metodo se ve de la siguiente manera. $$ x_{i+1} = x_i + k_2 $$ Donde: $$ k_1 = hf(x_i) $$ $$ k_2 = hf(x_i + \\frac{k_1}{2}, t + \\frac{h}{2}) $$ M\u00e9todo de Runge-Kutta de orden 4 El m\u00e9todo RK4 es una extension y mejora del metodo RK2, ahora con error de aproximacion del tama\u00f1o del paso elevado a la 5 y con nuevos terminos k, obteniendose la siguiente ecuacion. $$ x_{i+1} = x_{i} + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k4) $$ Donde: $$ k_1 = hf(x_i) $$ $$ k_2 = hf(x_i + \\frac{k_1}{2}, t + \\frac{h}{2}) $$ $$ k_3 = hf(x_i + \\frac{k_2}{2}, t + \\frac{h}{2}) $$ $$ k_4 = hf(x_i + k_3, t + \\frac{h}{2}) $$","title":"Home"},{"location":"#metodos-de-aproximacion","text":"En la resoluci\u00f3n de ecuaciones diferenciales ordinarias (ODEs), los m\u00e9todos num\u00e9ricos son esenciales para obtener aproximaciones cuando no se dispone de soluciones anal\u00edticas. A continuaci\u00f3n, se presenta una introducci\u00f3n a tres m\u00e9todos num\u00e9ricos comunes: el m\u00e9todo de Euler, el m\u00e9todo de Runge-Kutta de orden 2 (RK2) y el m\u00e9todo de Runge-Kutta de orden 4 (RK4).","title":"M\u00e9todos de aproximacion"},{"location":"#metodo-de-euler","text":"El m\u00e9todo de Euler es uno de los m\u00e9todos num\u00e9ricos m\u00e1s simples para resolver ODEs. Es un m\u00e9todo de primer orden, con error proporcional al cuadrado del tama\u00f1o del paso. La f\u00f3rmula b\u00e1sica para el m\u00e9todo de Euler es: $$ x_i = x_{i-1} + hf(x_i) $$ Donde: x_i - Es el valor de la funcion a aproximar evaluada en un tiempo t. h - Es el tama\u00f1o del paso f(x_i) - Es la funcion a la cual se le aplica el metodo.","title":"M\u00e9todo de Euler"},{"location":"#metodo-de-runge-kutta-de-orden-2","text":"El m\u00e9todo RK2 utiliza un punto medio para evaluar el m\u00e9todo de Euler, logrando una mejor aproximacion con un error del orden del cubo del tama\u00f1o del paso este m\u00e9todo se compone ahora de terminos k que se utlizan de manera recursiva, tal que el metodo se ve de la siguiente manera. $$ x_{i+1} = x_i + k_2 $$ Donde: $$ k_1 = hf(x_i) $$ $$ k_2 = hf(x_i + \\frac{k_1}{2}, t + \\frac{h}{2}) $$","title":"M\u00e9todo de Runge-Kutta de orden 2"},{"location":"#metodo-de-runge-kutta-de-orden-4","text":"El m\u00e9todo RK4 es una extension y mejora del metodo RK2, ahora con error de aproximacion del tama\u00f1o del paso elevado a la 5 y con nuevos terminos k, obteniendose la siguiente ecuacion. $$ x_{i+1} = x_{i} + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k4) $$ Donde: $$ k_1 = hf(x_i) $$ $$ k_2 = hf(x_i + \\frac{k_1}{2}, t + \\frac{h}{2}) $$ $$ k_3 = hf(x_i + \\frac{k_2}{2}, t + \\frac{h}{2}) $$ $$ k_4 = hf(x_i + k_3, t + \\frac{h}{2}) $$","title":"M\u00e9todo de Runge-Kutta de orden 4"},{"location":"about/","text":"Et hauriret silva non utilis fuit Diruta iterum viro rupit si quod laticemque Lorem markdownum mediam, sed pestiferaque dant, est fando suis, nostra, fratres patriisque saturata torumque. Ea venerat aequora cupio. Si effudit gaudet, voco illi amori saevarum canebat. Ille etiam, in formosos ! Consistere viribus sidus Echionides prodigiis enim magno hanc utraque preces tributuram, et inmitem ferit. Carbasa nitido monstravit ; et se abeunt; ave deus mihi Gyaros. Nihil dicit ductae cremantur te canibus vocas Turea trunca namque, neu tu cognoscere ursa vertuntur te. Omnia talia, Philomela festis, quae illuc tamen; quas auras. Populus longoque in pedes manu sorori refugitque summa, praeferret o vulgusque sic, ab. Iubet scilicet tigris: silvis nec haec voce, ridentem secreta, auro manusque fateri longi, molli. if (solid_inkjet == ad(expressionMemorySpider - 1, leakRosetta - driveControl, platform.clusterOemRpm.impactViewScreenshot(-2, arp, pageMultithreading))) { method = debug_number_design + bar; } deviceJoystick = cell(double); if (halftone_disk(minicomputer, displayParameterDock(editorMemoryAdd, kvm), metadata_web_controller) < webSector(jsp)) { kvmNum.iteration(1); } Torvo Chimaeriferae Labros Dianae, male et pascua genetrixque natus rursusque venturi ille Cinyran, inque Gangesque Centaurorum rogat antraque! Principio rursus, indicet; erit vaticinor audito cum leporem tacui, erat, studioque instabat iacent , poteremur. Nunc audete rege Suis et quidem nomine, nam mihi Persephone celsoque ausus adquirit dum amictus nunc, genitoris. Stetit orbe orbi; nec una: mora nihil e dumque Troiae et. Reportat saetae sanguine mirabere deripit domum. if (runtimeSnippetSystem + 4 * 5) { exabyte_editor.gigo_lock_memory(ripping_piconet, -5); tabletPage += balancingDomainLog.openglProgramBoot(skin); } var driveDeviceSocial = wired.biometricsRemoteServlet(type(tcpSoaFios, phreaking), 5 + gigabyte); if (marketStatus(viewRaidOs, pramDvd.pplViewView(55, 283959), dot( 855318))) { bandwidth_system_nui(newlineGisHfs.lun.xslt_cps(powerpoint, brouterRefresh, aspUp), metalSimm, url_arp_java(atm_cdfs, null_scrolling)); } else { matrix += copyrightPretestArchive; } Qua crocique auditque elusam procul ille serpens et corpore frondes, infelix illis metu remorata longior! Victor quateret iunctis nascique movebant tacitae volat siccatque tumidam origo iubete ut lupi. Est sine Derceti fugit quae; quid vultu fide: est nec cycnorum umeris sed aliqua qui.","title":"Et hauriret silva non utilis fuit"},{"location":"about/#et-hauriret-silva-non-utilis-fuit","text":"","title":"Et hauriret silva non utilis fuit"},{"location":"about/#diruta-iterum-viro-rupit-si-quod-laticemque","text":"Lorem markdownum mediam, sed pestiferaque dant, est fando suis, nostra, fratres patriisque saturata torumque. Ea venerat aequora cupio. Si effudit gaudet, voco illi amori saevarum canebat. Ille etiam, in formosos ! Consistere viribus sidus Echionides prodigiis enim magno hanc utraque preces tributuram, et inmitem ferit. Carbasa nitido monstravit ; et se abeunt; ave deus mihi Gyaros.","title":"Diruta iterum viro rupit si quod laticemque"},{"location":"about/#nihil-dicit-ductae-cremantur-te-canibus-vocas","text":"Turea trunca namque, neu tu cognoscere ursa vertuntur te. Omnia talia, Philomela festis, quae illuc tamen; quas auras. Populus longoque in pedes manu sorori refugitque summa, praeferret o vulgusque sic, ab. Iubet scilicet tigris: silvis nec haec voce, ridentem secreta, auro manusque fateri longi, molli. if (solid_inkjet == ad(expressionMemorySpider - 1, leakRosetta - driveControl, platform.clusterOemRpm.impactViewScreenshot(-2, arp, pageMultithreading))) { method = debug_number_design + bar; } deviceJoystick = cell(double); if (halftone_disk(minicomputer, displayParameterDock(editorMemoryAdd, kvm), metadata_web_controller) < webSector(jsp)) { kvmNum.iteration(1); } Torvo Chimaeriferae Labros Dianae, male et pascua genetrixque natus rursusque venturi ille Cinyran, inque Gangesque Centaurorum rogat antraque! Principio rursus, indicet; erit vaticinor audito cum leporem tacui, erat, studioque instabat iacent , poteremur.","title":"Nihil dicit ductae cremantur te canibus vocas"},{"location":"about/#nunc-audete-rege","text":"Suis et quidem nomine, nam mihi Persephone celsoque ausus adquirit dum amictus nunc, genitoris. Stetit orbe orbi; nec una: mora nihil e dumque Troiae et. Reportat saetae sanguine mirabere deripit domum. if (runtimeSnippetSystem + 4 * 5) { exabyte_editor.gigo_lock_memory(ripping_piconet, -5); tabletPage += balancingDomainLog.openglProgramBoot(skin); } var driveDeviceSocial = wired.biometricsRemoteServlet(type(tcpSoaFios, phreaking), 5 + gigabyte); if (marketStatus(viewRaidOs, pramDvd.pplViewView(55, 283959), dot( 855318))) { bandwidth_system_nui(newlineGisHfs.lun.xslt_cps(powerpoint, brouterRefresh, aspUp), metalSimm, url_arp_java(atm_cdfs, null_scrolling)); } else { matrix += copyrightPretestArchive; } Qua crocique auditque elusam procul ille serpens et corpore frondes, infelix illis metu remorata longior! Victor quateret iunctis nascique movebant tacitae volat siccatque tumidam origo iubete ut lupi. Est sine Derceti fugit quae; quid vultu fide: est nec cycnorum umeris sed aliqua qui.","title":"Nunc audete rege"},{"location":"calcu/","text":"Calcu Este modulo contiene algunas operaciones Suma Resta Multiplicacion Division add ( a , b ) Se retorna la suma de a y b Parameters: a ( float ) \u2013 Numero b ( float ) \u2013 Segundo numero Returns: \u2013 Regresa la suma de los numeros a y b Examples: >>> add ( 2 , 3 ) >>> 5 .. image:: ../docs/img/Naruto_I.jpg :aling: center Source code in calcu/calcu.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def add ( a , b ): \"\"\" Se retorna la suma de a y b Args: a (float): Numero b (float): Segundo numero Returns: Regresa la suma de los numeros a y b Examples: >>> add(2,3) >>> 5 .. image:: ../docs/img/Naruto_I.jpg :aling: center \"\"\" return float ( a + b ) res ( a , b ) Se retorna la resta de a y b Parameters: a ( float ) \u2013 Numero b ( float ) \u2013 Segundo numero Returns: \u2013 Regresa la resta de los numeros a y b Examples: >>> res ( 5 , 3 ) >>> 3 Source code in calcu/calcu.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def res ( a , b ): \"\"\" Se retorna la resta de a y b Args: a (float): Numero b (float): Segundo numero Returns: Regresa la resta de los numeros a y b Examples: >>> res(5,3) >>> 3 \"\"\" return float ( a - b )","title":"Calcu"},{"location":"calcu/#calcu","text":"Este modulo contiene algunas operaciones Suma Resta Multiplicacion Division","title":"Calcu"},{"location":"calcu/#calcu.calcu.add","text":"Se retorna la suma de a y b Parameters: a ( float ) \u2013 Numero b ( float ) \u2013 Segundo numero Returns: \u2013 Regresa la suma de los numeros a y b Examples: >>> add ( 2 , 3 ) >>> 5 .. image:: ../docs/img/Naruto_I.jpg :aling: center Source code in calcu/calcu.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def add ( a , b ): \"\"\" Se retorna la suma de a y b Args: a (float): Numero b (float): Segundo numero Returns: Regresa la suma de los numeros a y b Examples: >>> add(2,3) >>> 5 .. image:: ../docs/img/Naruto_I.jpg :aling: center \"\"\" return float ( a + b )","title":"add"},{"location":"calcu/#calcu.calcu.res","text":"Se retorna la resta de a y b Parameters: a ( float ) \u2013 Numero b ( float ) \u2013 Segundo numero Returns: \u2013 Regresa la resta de los numeros a y b Examples: >>> res ( 5 , 3 ) >>> 3 Source code in calcu/calcu.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def res ( a , b ): \"\"\" Se retorna la resta de a y b Args: a (float): Numero b (float): Segundo numero Returns: Regresa la resta de los numeros a y b Examples: >>> res(5,3) >>> 3 \"\"\" return float ( a - b )","title":"res"},{"location":"ejemplos/","text":"Ejemplos de funciones hechas por los distintos metodos Todas los metodos intentaron aproximar la funcion con 20 iteraciones $$ \\frac{dx}{dt} = -x^{3} + \\sin(t) $$ Grafica para la funcion obtenida con el metodo de euler Grafica para la funcion obtenida con el metodo de RK de segundo orden Grafica para la funcion obtenida con el metodo de RK de cuarto orden","title":"Ejemplos"},{"location":"ejemplos/#ejemplos-de-funciones-hechas-por-los-distintos-metodos","text":"Todas los metodos intentaron aproximar la funcion con 20 iteraciones $$ \\frac{dx}{dt} = -x^{3} + \\sin(t) $$ Grafica para la funcion obtenida con el metodo de euler Grafica para la funcion obtenida con el metodo de RK de segundo orden Grafica para la funcion obtenida con el metodo de RK de cuarto orden","title":"Ejemplos de funciones hechas por los distintos metodos"},{"location":"ode/","text":"Metodos de aproximacion Este modulo contiene funciones que implementan metodos usados para aproximar ODES dichos metododos son el metodo de euler, RK de segundo grado y RK de cuarto grado. eu ( f , x_0 , t_0 , N , tf ) Esta funcion implementa el metodo de euler para aproximar una ODE Parameters: f ( funtion ) \u2013 Funcion a la cual aplicar el metodo de euler x_0 ( float ) \u2013 Valor de frontera dado, ejemplo x(0)=0 t_0 ( float ) \u2013 Valor inicial desde el cual se va a evaluar la funcion a encontrar N ( int ) \u2013 Numero de pasos a iterar con cierto tama\u00f1o. tf ( float ) \u2013 Valor final hasta el cual se va a evaluar la funcion a encontrar Returns: string \u2013 Devuele 2 hileras, una con los tiempos en los cuales se evaluo la funcion y la otra hilera es la funcion evaluada en esos puntos, es decir la ODE a encontrar. Example: >>> eu(fun,0,0,20,10): >>> ver seccion ejemplo para la ver la grafica de la funcion Source code in ode/ode.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def eu ( f , x_0 , t_0 , N , tf ): \"\"\" Esta funcion implementa el metodo de euler para aproximar una ODE Args: f (funtion): Funcion a la cual aplicar el metodo de euler x_0 (float): Valor de frontera dado, ejemplo x(0)=0 t_0 (float): Valor inicial desde el cual se va a evaluar la funcion a encontrar N (int): Numero de pasos a iterar con cierto tama\u00f1o. tf (float): Valor final hasta el cual se va a evaluar la funcion a encontrar Returns: string: Devuele 2 hileras, una con los tiempos en los cuales se evaluo la funcion y la otra hilera es la funcion evaluada en esos puntos, es decir la ODE a encontrar. Example: >>> eu(fun,0,0,20,10): >>> ver seccion ejemplo para la ver la grafica de la funcion \"\"\" h = ( tf - t_0 ) / N ts = np . linspace ( t_0 , tf , N ) xs = np . zeros ( len ( ts )) xs [ 0 ] = x_0 for i in range ( 0 , len ( ts ) - 1 ): xs [ i + 1 ] = xs [ i ] + h * f ( xs [ i ], ts [ i ]) return ts , xs rk2 ( f , t_0 , x_0 , N , tf ) Esta funcion implementa el metodo de RK de segundo orden para aproximar una ODE Parameters: f ( funtion ) \u2013 Funcion a la cual aplicar el metodo de RK2 x_0 ( float ) \u2013 Valor de frontera dado, ejemplo x(0)=0 t_0 ( float ) \u2013 Valor inicial desde el cual se va a evaluar la funcion a encontrar N ( int ) \u2013 Numero de pasos a iterar con cierto tama\u00f1o. tf ( float ) \u2013 Valor final hasta el cual se va a evaluar la funcion a encontrar Returns: string \u2013 Devuele 2 hileras, una con los tiempos en los cuales se evaluo la funcion y la otra hilera es la funcion evaluada en esos puntos, es decir la ODE a encontrar. Example: >>> rk2(fun,0,0,20,10): >>> ver seccion ejemplo para la ver la grafica de la funcion Source code in ode/ode.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def rk2 ( f , t_0 , x_0 , N , tf ): \"\"\" Esta funcion implementa el metodo de RK de segundo orden para aproximar una ODE Args: f (funtion): Funcion a la cual aplicar el metodo de RK2 x_0 (float): Valor de frontera dado, ejemplo x(0)=0 t_0 (float): Valor inicial desde el cual se va a evaluar la funcion a encontrar N (int): Numero de pasos a iterar con cierto tama\u00f1o. tf (float): Valor final hasta el cual se va a evaluar la funcion a encontrar Returns: string: Devuele 2 hileras, una con los tiempos en los cuales se evaluo la funcion y la otra hilera es la funcion evaluada en esos puntos, es decir la ODE a encontrar. Example: >>> rk2(fun,0,0,20,10): >>> ver seccion ejemplo para la ver la grafica de la funcion \"\"\" h = ( tf - t_0 ) / N ts = np . linspace ( t_0 , tf , N ) xs = np . zeros ( len ( ts )) xs [ 0 ] = x_0 for i in range ( len ( ts ) - 1 ): k1 = h * f ( xs [ i ], ts [ i ]) k2 = h * f ( xs [ i ] + k1 / 2 , ts [ i ] + h / 2 ) xs [ i + 1 ] = xs [ i ] + k2 return ts , xs rk4 ( f , x_0 , t_0 , N , tf ) Esta funcion implementa el metodo de RK de cuarto orden para aproximar una ODE Parameters: f ( funtion ) \u2013 Funcion a la cual aplicar el metodo de RK4 x_0 ( float ) \u2013 Valor de frontera dado, ejemplo x(0)=0 t_0 ( float ) \u2013 Valor inicial desde el cual se va a evaluar la funcion a encontrar N ( int ) \u2013 Numero de pasos a iterar con cierto tama\u00f1o. tf ( float ) \u2013 Valor final hasta el cual se va a evaluar la funcion a encontrar Returns: string \u2013 Devuele 2 hileras, una con los tiempos en los cuales se evaluo la funcion y la otra hilera es la funcion evaluada en esos puntos, es decir la ODE a encontrar. Example: >>> rk4(fun,0,0,20,10): >>> ver seccion ejemplo para la ver la grafica de la funcion Source code in ode/ode.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def rk4 ( f , x_0 , t_0 , N , tf ): \"\"\" Esta funcion implementa el metodo de RK de cuarto orden para aproximar una ODE Args: f (funtion): Funcion a la cual aplicar el metodo de RK4 x_0 (float): Valor de frontera dado, ejemplo x(0)=0 t_0 (float): Valor inicial desde el cual se va a evaluar la funcion a encontrar N (int): Numero de pasos a iterar con cierto tama\u00f1o. tf (float): Valor final hasta el cual se va a evaluar la funcion a encontrar Returns: string: Devuele 2 hileras, una con los tiempos en los cuales se evaluo la funcion y la otra hilera es la funcion evaluada en esos puntos, es decir la ODE a encontrar. Example: >>> rk4(fun,0,0,20,10): >>> ver seccion ejemplo para la ver la grafica de la funcion \"\"\" h = ( tf - t_0 ) / N ts = np . linspace ( t_0 , tf , N ) xs = np . zeros ( len ( ts )) xs [ 0 ] = x_0 for i in range ( len ( ts ) - 1 ): k1 = h * f ( xs [ i ], ts [ i ]) k2 = h * f ( xs [ i ] + k1 / 2 , ts [ i ] + h / 2 ) k3 = h * f ( xs [ i ] + k2 / 2 , ts [ i ] + h / 2 ) k4 = h * f ( xs [ i ] + k3 , ts [ i ] + h ) xs [ i + 1 ] = xs [ i ] + ( 1 / 6 ) * ( k1 + 2 * k2 + 2 * k3 + k4 ) return ts , xs","title":"Reference"},{"location":"ode/#metodos-de-aproximacion","text":"Este modulo contiene funciones que implementan metodos usados para aproximar ODES dichos metododos son el metodo de euler, RK de segundo grado y RK de cuarto grado.","title":"Metodos de aproximacion"},{"location":"ode/#ode.ode.eu","text":"Esta funcion implementa el metodo de euler para aproximar una ODE Parameters: f ( funtion ) \u2013 Funcion a la cual aplicar el metodo de euler x_0 ( float ) \u2013 Valor de frontera dado, ejemplo x(0)=0 t_0 ( float ) \u2013 Valor inicial desde el cual se va a evaluar la funcion a encontrar N ( int ) \u2013 Numero de pasos a iterar con cierto tama\u00f1o. tf ( float ) \u2013 Valor final hasta el cual se va a evaluar la funcion a encontrar Returns: string \u2013 Devuele 2 hileras, una con los tiempos en los cuales se evaluo la funcion y la otra hilera es la funcion evaluada en esos puntos, es decir la ODE a encontrar. Example: >>> eu(fun,0,0,20,10): >>> ver seccion ejemplo para la ver la grafica de la funcion Source code in ode/ode.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def eu ( f , x_0 , t_0 , N , tf ): \"\"\" Esta funcion implementa el metodo de euler para aproximar una ODE Args: f (funtion): Funcion a la cual aplicar el metodo de euler x_0 (float): Valor de frontera dado, ejemplo x(0)=0 t_0 (float): Valor inicial desde el cual se va a evaluar la funcion a encontrar N (int): Numero de pasos a iterar con cierto tama\u00f1o. tf (float): Valor final hasta el cual se va a evaluar la funcion a encontrar Returns: string: Devuele 2 hileras, una con los tiempos en los cuales se evaluo la funcion y la otra hilera es la funcion evaluada en esos puntos, es decir la ODE a encontrar. Example: >>> eu(fun,0,0,20,10): >>> ver seccion ejemplo para la ver la grafica de la funcion \"\"\" h = ( tf - t_0 ) / N ts = np . linspace ( t_0 , tf , N ) xs = np . zeros ( len ( ts )) xs [ 0 ] = x_0 for i in range ( 0 , len ( ts ) - 1 ): xs [ i + 1 ] = xs [ i ] + h * f ( xs [ i ], ts [ i ]) return ts , xs","title":"eu"},{"location":"ode/#ode.ode.rk2","text":"Esta funcion implementa el metodo de RK de segundo orden para aproximar una ODE Parameters: f ( funtion ) \u2013 Funcion a la cual aplicar el metodo de RK2 x_0 ( float ) \u2013 Valor de frontera dado, ejemplo x(0)=0 t_0 ( float ) \u2013 Valor inicial desde el cual se va a evaluar la funcion a encontrar N ( int ) \u2013 Numero de pasos a iterar con cierto tama\u00f1o. tf ( float ) \u2013 Valor final hasta el cual se va a evaluar la funcion a encontrar Returns: string \u2013 Devuele 2 hileras, una con los tiempos en los cuales se evaluo la funcion y la otra hilera es la funcion evaluada en esos puntos, es decir la ODE a encontrar. Example: >>> rk2(fun,0,0,20,10): >>> ver seccion ejemplo para la ver la grafica de la funcion Source code in ode/ode.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def rk2 ( f , t_0 , x_0 , N , tf ): \"\"\" Esta funcion implementa el metodo de RK de segundo orden para aproximar una ODE Args: f (funtion): Funcion a la cual aplicar el metodo de RK2 x_0 (float): Valor de frontera dado, ejemplo x(0)=0 t_0 (float): Valor inicial desde el cual se va a evaluar la funcion a encontrar N (int): Numero de pasos a iterar con cierto tama\u00f1o. tf (float): Valor final hasta el cual se va a evaluar la funcion a encontrar Returns: string: Devuele 2 hileras, una con los tiempos en los cuales se evaluo la funcion y la otra hilera es la funcion evaluada en esos puntos, es decir la ODE a encontrar. Example: >>> rk2(fun,0,0,20,10): >>> ver seccion ejemplo para la ver la grafica de la funcion \"\"\" h = ( tf - t_0 ) / N ts = np . linspace ( t_0 , tf , N ) xs = np . zeros ( len ( ts )) xs [ 0 ] = x_0 for i in range ( len ( ts ) - 1 ): k1 = h * f ( xs [ i ], ts [ i ]) k2 = h * f ( xs [ i ] + k1 / 2 , ts [ i ] + h / 2 ) xs [ i + 1 ] = xs [ i ] + k2 return ts , xs","title":"rk2"},{"location":"ode/#ode.ode.rk4","text":"Esta funcion implementa el metodo de RK de cuarto orden para aproximar una ODE Parameters: f ( funtion ) \u2013 Funcion a la cual aplicar el metodo de RK4 x_0 ( float ) \u2013 Valor de frontera dado, ejemplo x(0)=0 t_0 ( float ) \u2013 Valor inicial desde el cual se va a evaluar la funcion a encontrar N ( int ) \u2013 Numero de pasos a iterar con cierto tama\u00f1o. tf ( float ) \u2013 Valor final hasta el cual se va a evaluar la funcion a encontrar Returns: string \u2013 Devuele 2 hileras, una con los tiempos en los cuales se evaluo la funcion y la otra hilera es la funcion evaluada en esos puntos, es decir la ODE a encontrar. Example: >>> rk4(fun,0,0,20,10): >>> ver seccion ejemplo para la ver la grafica de la funcion Source code in ode/ode.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def rk4 ( f , x_0 , t_0 , N , tf ): \"\"\" Esta funcion implementa el metodo de RK de cuarto orden para aproximar una ODE Args: f (funtion): Funcion a la cual aplicar el metodo de RK4 x_0 (float): Valor de frontera dado, ejemplo x(0)=0 t_0 (float): Valor inicial desde el cual se va a evaluar la funcion a encontrar N (int): Numero de pasos a iterar con cierto tama\u00f1o. tf (float): Valor final hasta el cual se va a evaluar la funcion a encontrar Returns: string: Devuele 2 hileras, una con los tiempos en los cuales se evaluo la funcion y la otra hilera es la funcion evaluada en esos puntos, es decir la ODE a encontrar. Example: >>> rk4(fun,0,0,20,10): >>> ver seccion ejemplo para la ver la grafica de la funcion \"\"\" h = ( tf - t_0 ) / N ts = np . linspace ( t_0 , tf , N ) xs = np . zeros ( len ( ts )) xs [ 0 ] = x_0 for i in range ( len ( ts ) - 1 ): k1 = h * f ( xs [ i ], ts [ i ]) k2 = h * f ( xs [ i ] + k1 / 2 , ts [ i ] + h / 2 ) k3 = h * f ( xs [ i ] + k2 / 2 , ts [ i ] + h / 2 ) k4 = h * f ( xs [ i ] + k3 , ts [ i ] + h ) xs [ i + 1 ] = xs [ i ] + ( 1 / 6 ) * ( k1 + 2 * k2 + 2 * k3 + k4 ) return ts , xs","title":"rk4"},{"location":"ondex/","text":"M\u00e9todos de aproximacion En la resoluci\u00f3n de ecuaciones diferenciales ordinarias (ODEs), los m\u00e9todos num\u00e9ricos son esenciales para obtener aproximaciones cuando no se dispone de soluciones anal\u00edticas. A continuaci\u00f3n, se presenta una introducci\u00f3n a tres m\u00e9todos num\u00e9ricos comunes: el m\u00e9todo de Euler, el m\u00e9todo de Runge-Kutta de orden 2 (RK2) y el m\u00e9todo de Runge-Kutta de orden 4 (RK4). M\u00e9todo de Euler El m\u00e9todo de Euler es uno de los m\u00e9todos num\u00e9ricos m\u00e1s simples para resolver ODEs. Es un m\u00e9todo de primer orden, con error proporcional al cuadrado del tama\u00f1o del paso. La f\u00f3rmula b\u00e1sica para el m\u00e9todo de Euler es: $$ x_i = x_{i-1} + hf(x_i) $$ Donde: x_i - Es el valor de la funcion a aproximar evaluada en un tiempo t. h - Es el tama\u00f1o del paso f(x_i) - Es la funcion a la cual se le aplica el metodo. M\u00e9todo de Runge-Kutta de orden 2 El m\u00e9todo RK2 utiliza un punto medio para evaluar el m\u00e9todo de Euler, logrando una mejor aproximacion con un error del orden del cubo del tama\u00f1o del paso este m\u00e9todo se compone ahora de terminos k que se utlizan de manera recursiva, tal que el metodo se ve de la siguiente manera. $$ x_{i+1} = x_i + k_2 $$ Donde: $$ k_1 = hf(x_i) $$ $$ k_2 = hf(x_i + \\frac{k_1}{2}, t + \\frac{h}{2}) $$ M\u00e9todo de Runge-Kutta de orden 4 El m\u00e9todo RK4 es una extension y mejora del metodo RK2, ahora con error de aproximacion del tama\u00f1o del paso elevado a la 5 y con nuevos terminos k, obteniendose la siguiente ecuacion. $$ x_{i+1} = x_{i} + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k4) $$ Donde: $$ k_1 = hf(x_i) $$ $$ k_2 = hf(x_i + \\frac{k_1}{2}, t + \\frac{h}{2}) $$ $$ k_3 = hf(x_i + \\frac{k_2}{2}, t + \\frac{h}{2}) $$ $$ k_4 = hf(x_i + k_3, t + \\frac{h}{2}) $$","title":"Index"},{"location":"ondex/#metodos-de-aproximacion","text":"En la resoluci\u00f3n de ecuaciones diferenciales ordinarias (ODEs), los m\u00e9todos num\u00e9ricos son esenciales para obtener aproximaciones cuando no se dispone de soluciones anal\u00edticas. A continuaci\u00f3n, se presenta una introducci\u00f3n a tres m\u00e9todos num\u00e9ricos comunes: el m\u00e9todo de Euler, el m\u00e9todo de Runge-Kutta de orden 2 (RK2) y el m\u00e9todo de Runge-Kutta de orden 4 (RK4).","title":"M\u00e9todos de aproximacion"},{"location":"ondex/#metodo-de-euler","text":"El m\u00e9todo de Euler es uno de los m\u00e9todos num\u00e9ricos m\u00e1s simples para resolver ODEs. Es un m\u00e9todo de primer orden, con error proporcional al cuadrado del tama\u00f1o del paso. La f\u00f3rmula b\u00e1sica para el m\u00e9todo de Euler es: $$ x_i = x_{i-1} + hf(x_i) $$ Donde: x_i - Es el valor de la funcion a aproximar evaluada en un tiempo t. h - Es el tama\u00f1o del paso f(x_i) - Es la funcion a la cual se le aplica el metodo.","title":"M\u00e9todo de Euler"},{"location":"ondex/#metodo-de-runge-kutta-de-orden-2","text":"El m\u00e9todo RK2 utiliza un punto medio para evaluar el m\u00e9todo de Euler, logrando una mejor aproximacion con un error del orden del cubo del tama\u00f1o del paso este m\u00e9todo se compone ahora de terminos k que se utlizan de manera recursiva, tal que el metodo se ve de la siguiente manera. $$ x_{i+1} = x_i + k_2 $$ Donde: $$ k_1 = hf(x_i) $$ $$ k_2 = hf(x_i + \\frac{k_1}{2}, t + \\frac{h}{2}) $$","title":"M\u00e9todo de Runge-Kutta de orden 2"},{"location":"ondex/#metodo-de-runge-kutta-de-orden-4","text":"El m\u00e9todo RK4 es una extension y mejora del metodo RK2, ahora con error de aproximacion del tama\u00f1o del paso elevado a la 5 y con nuevos terminos k, obteniendose la siguiente ecuacion. $$ x_{i+1} = x_{i} + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k4) $$ Donde: $$ k_1 = hf(x_i) $$ $$ k_2 = hf(x_i + \\frac{k_1}{2}, t + \\frac{h}{2}) $$ $$ k_3 = hf(x_i + \\frac{k_2}{2}, t + \\frac{h}{2}) $$ $$ k_4 = hf(x_i + k_3, t + \\frac{h}{2}) $$","title":"M\u00e9todo de Runge-Kutta de orden 4"}]}